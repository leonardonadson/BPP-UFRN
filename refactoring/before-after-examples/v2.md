# Atualização #2: Separação de Responsabilidades no Registo
Nesta atualização, a função register_user foi refatorada para separar a validação da criação, aplicando o Princípio da Responsabilidade Única.

**ANTES (em routers/auth.py):**

    @router.post("/register", response_model=User, status_code=status.HTTP_201_CREATED)
    def register_user(user: UserCreate, db: Session = Depends(get_db)):
        """Registra um novo usuário"""
        # Validação e criação misturadas
        if db.query(UserModel).filter(UserModel.email == user.email).first():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email já cadastrado"
            )

        if db.query(UserModel).filter(UserModel.username == user.username).first():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Nome de usuário já existe"
            )

        hashed_password = get_password_hash(user.password)
        db_user = UserModel(
            email=user.email,
            username=user.username,
            hashed_password=hashed_password
        )

        db.add(db_user)
        db.commit()
        db.refresh(db_user)

        return db_user

**DEPOIS (em routers/auth.py):**

    def _validate_user_creation(user_data: UserCreate, db: Session):
        """Verifica se o email e o username já estão em uso."""
        if db.query(UserModel).filter(UserModel.email == user_data.email).first():
            raise HTTPException(...)

        if db.query(UserModel).filter(UserModel.username == user_data.username).first():
            raise HTTPException(...)

    @router.post("/register", response_model=User, status_code=status.HTTP_201_CREATED)
    def register_user(user: UserCreate, db: Session = Depends(get_db)):
        """Registra um novo usuário após validar os dados."""
        # Passo 1: Validação (agora em uma chamada de função clara)
        _validate_user_creation(user, db)

        # Passo 2: Criação (a responsabilidade principal da função)
        hashed_password = get_password_hash(user.password)
        db_user = UserModel(...)
        db.add(db_user)
        db.commit()
        db.refresh(db_user)

        return db_user